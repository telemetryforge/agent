name: Reusable workflow to test packages
on:
  workflow_call:
    inputs:
      build-matrix:
        description: The JSON matrix of build targets, this will be processed and converted to test targets.
        required: true
        type: string
      version:
        description: The version we are building for (as a numeric value 1.2.3).
        required: true
        type: string
      ref:
        description: The commit, SHA or branch to use in this repository.
        required: false
        type: string
        default: main
      dockerhub-username:
        description: The Dockerhub username to use for authenticated pulls.
        required: false
        type: string
        default: "telemetryforge"
      amd-runner-label:
        description: The label to use for the runner.
        required: false
        type: string
        default: "namespace-profile-ubuntu-latest"
    secrets:
      github-token:
        description: Token to use to pull packages from GitHub Packages.
        required: true
      dockerhub-token:
        description: The Dockerhub token to use for authenticated pulls (not pushes).
        required: true
env:
  TELEMETRY_FORGE_AGENT_VERSION: ${{ inputs.version }}
jobs:
  # This job converts the JSON build-matrix coming in to a matrix of test jobs.
  # We convert using the following rules:
  # 1. Drop any arm64v8 targets - we only test AMD64 packages for now.
  # 2. Convert the distro value from something like 'centos/8' to 'dokken/centos-8'
  # Finally we output another JSON matrix to use for call-test-packages-functional.
  call-test-packages-get-meta:
    name: Get metadata for testing
    runs-on: ubuntu-latest
    outputs:
      linux-test-targets: ${{ steps.get_matrix.outputs.linux_test_targets }}
    steps:
      - name: Log in to Dockerhub
        if: ${{ !env.ACT }}
        uses: docker/login-action@v3
        with:
          username: ${{ inputs.dockerhub-username }}
          password: ${{ secrets.dockerhub-token }}

      - name: Create matrix from input matrix and verify pullable images
        id: get_matrix
        run: |
          set -euo pipefail
          json='${{ inputs.build-matrix }}'
          echo "Input JSON: $json"

          # Build initial candidates: drop arm64 entries, unsupported CentOS versions and map distro -> image
          echo "$json" | jq -c '[.[] | select(endswith(".arm64v8") | not) | select(. != "centos/7" and . != "centos/8") | {distro: ., image: ("dokken/" + (gsub("/"; "-")))}]' > /tmp/candidates.json
          echo "Candidates:"
          jq -r '.[] | "\(.distro) -> \(.image)"' /tmp/candidates.json || true

          # Test docker pull for each candidate, keep only successful pulls
          valid_json_items=()
          while read -r item; do
            distro=$(echo "$item" | jq -r '.distro')
            image=$(echo "$item" | jq -r '.image')
            echo "Testing docker pull for: $image (distro: $distro)"
            if docker pull "$image" >/tmp/pull.out 2>&1; then
              echo "OK: $image"
              valid_json_items+=("$item")
            else
              echo "SKIP (cannot pull): $image"
              echo "docker pull output:"
              sed -n '1,200p' /tmp/pull.out || true
            fi
          done < <(jq -c '.[]' /tmp/candidates.json)

          # Compose final JSON array
          if [ "${#valid_json_items[@]}" -eq 0 ]; then
            final='[]'
          else
            printf '%s\n' "${valid_json_items[@]}" | jq -s '.' > /tmp/final.json
            final="$(jq -c . /tmp/final.json)"
          fi

          echo "Final matrix: $final"
          echo '-------'
          echo "$final" | jq .
          # Emit the JSON array as a step output
          echo "linux_test_targets=$final" >> "$GITHUB_OUTPUT"
        shell: bash

  call-test-packages-functional:
    name: functional tests - ${{ matrix.config.distro }} package test
    needs:
      - call-test-packages-get-meta
    # We only run tests on AMD runners here
    runs-on: ${{ inputs.amd-runner-label }}
    timeout-minutes: 30
    permissions:
      contents: read
      packages: read
    strategy:
      fail-fast: false
      matrix:
        config: ${{ fromJson(needs.call-test-packages-get-meta.outputs.linux-test-targets) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          repository: telemetryforge/agent
          ref: ${{ inputs.ref }}

      - name: Log in to Dockerhub
        if: ${{ !env.ACT }}
        uses: docker/login-action@v3
        with:
          username: ${{ inputs.dockerhub-username }}
          password: ${{ secrets.dockerhub-token }}

      # Must be removed on Namespace runners
      - name: Set up QEMU
        if: ${{ !contains( runner.name, 'nsc-' ) }}
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        if: ${{ !contains( runner.name, 'nsc-' ) }}
        uses: docker/setup-buildx-action@v3

      - name: Get package name
        uses: ./.github/actions/get-package-name
        id: get_package_name
        with:
          distro: "${{ matrix.config.distro }}"

      - name: Download package
        if: ${{ !env.ACT }}
        uses: actions/download-artifact@v7
        with:
          name: ${{ steps.get_package_name.outputs.package-name }}
          path: downloads/

      - name: Debug
        run: ls -lRh downloads/
        shell: bash

      - name: Run package tests for ${{ matrix.config.distro }}
        run: ./testing/bats/run-package-functional-tests.sh
        shell: bash
        env:
          BASE_IMAGE: ${{ matrix.config.image }}
          DISTRO: ${{ matrix.config.distro }}

  # Test packages installed on the actual target OS
  # For now we just use the ephemeral runners
  # TODO: provide testing on target VMs or similar
  call-test-packages-integration:
    name: integration tests - ${{ matrix.name }} package test
    runs-on: ${{ matrix.runner }}
    timeout-minutes: 30
    permissions:
      contents: read
      packages: read
    strategy:
      fail-fast: false
      matrix:
        include:
          - runner: ubuntu-24.04
            package-type: deb
            package: package-ubuntu-24.04
            name: ubuntu
            binary: /opt/telemetryforge-agent/bin/fluent-bit
          # - runner: windows-latest
          #   package-type: msi
          #   package: package-windows
          #   name: windows MSI
          #   binary: C:\fluent-bit\bin\fluent-bit
    env:
      FLUENT_BIT_BINARY: ${{ matrix.binary }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          repository: telemetryforge/agent
          ref: ${{ inputs.ref }}

      # Must be removed on Namespace runners
      - name: Set up QEMU
        if: ${{ !contains( runner.name, 'nsc-' ) }}
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        if: ${{ !contains( runner.name, 'nsc-' ) }}
        uses: docker/setup-buildx-action@v3

      - name: Install BATS
        uses: bats-core/bats-action@3.0.1
        with:
          assert-install: false
          detik-install: false
          file-install: false
          support-install: false

      - name: Download package
        uses: actions/download-artifact@v7
        with:
          name: ${{ matrix.package }}
          path: downloads/

      - name: Debug
        run: ls -lRh downloads/
        shell: bash

      - name: Install package
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          find "$PWD/downloads/" -name '*.deb' -exec sh -c 'i="$1";echo "$i";sudo apt-get install -y "$i"' shell {} \;
        shell: bash

      - name: Install package
        if: runner.os == 'Windows'
        run: |
          $msi = Get-ChildItem -Path ".\downloads" -Filter "*.msi" | Select-Object -First 1
          msiexec.exe /i "$($msi.FullName)" /quiet /qn
        shell: pwsh

      - name: Run integration tests
        run: ./testing/bats/run-package-integration-tests.sh
        shell: bash

      - name: Debug linux binary
        if: runner.os == 'Linux'
        continue-on-error: true
        run: |
          ls -lRh /opt
          ls -lRh "${{ matrix.binary }}" || true
          "${{ matrix.binary }}" --version || true
        shell: bash

      - name: Debug windows binary
        if: runner.os == 'Windows'
        continue-on-error: true
        run: |
          $binaryPath = "${{ matrix.binary }}"
          Get-Item -Path $binaryPath | Format-List -Property *
          & $binaryPath --version
        shell: pwsh
